#lang typed/racket
(require typed/rackunit)


;; 3 write parser and interp

;; Data definitions
(define-type ExprC (U NumC BinopC Leq0 IdC AppC))
(struct NumC ([n : Real]) #:transparent)

; fds
(struct FdC ([name : Symbol] [arg : Symbol] [body : ExprC]) #:transparent)

(define invalid-id-hash
  (hash '+ +
        '- -
        '* *
        '/ /
        'def 'def
        'leq0? 'leq0?
        'then 'then
        'else 'else
        '= '=))

; binop
(struct BinopC ([operator : Symbol] [l : ExprC] [r : ExprC]) #:transparent)

; conditional
(struct Leq0 ([test : ExprC] [then : ExprC] [else : ExprC]) #:transparent)

; function stuff

(struct IdC ([s : Symbol]) #:transparent) ;; an ID element
(struct AppC ([fun : Symbol] [expr : ExprC]) #:transparent) ;; application of a func


;;placeholder fds (function definitions) that will later be generated by parse-prog i think
(define testFds ( list (FdC 'f 'x (BinopC '+ (NumC 2) (IdC 'x))) (FdC 'g 'y (BinopC '+ (NumC 5) (IdC 'y)))))
;(define fds (list))

;; takes any and returns if it is a valid-id as a bool 
(define (valid-id? [id : Any]) : Boolean
  (match id
    [(? symbol? s) (not (hash-has-key? invalid-id-hash s))]
    [other false]))
(check-equal? (valid-id? 'hi) true)
(check-equal? (valid-id? "hi") false)
(check-equal? (valid-id? '/) false)
;;placeholder get-fundef
#;(define (get-fundef [s : Symbol] [fundefs : (Listof FdC)]) : FdC
  (FdC 'f 'x (BinopC '+ (NumC 2) (IdC 'x))))

;; 3.1 Binary Arithmetic Operators
(define (get-operator [operator : Symbol]) : (-> Real Real Real)
  (match operator
    ['+ +]
    ['* *]
    ['- -]
    ['/ /]
    [other (error "VVQS: error -- expected a valid operator (+, -, *, /), got ~e" other)]))

(check-exn #rx"VVQS" (lambda() (get-operator '\))))



;; PARSER

;; takes an Sexp and returns the ExprC corresponding to the Sexp, if applicable.
;; if not, an error is thrown
(define (parse [expr : Sexp]) : ExprC
 (match expr
     [(? real? n) (NumC n)]
     [(list (? symbol? s) l r) (BinopC s (parse l) (parse r))]
     [(list 'leq0? test 'then then 'else else) (Leq0 (parse test) (parse then) (parse else))]
     [(? symbol? sym) (cond
                        [(valid-id? sym) (IdC (cast sym Symbol))]
                        [else (error "VVQS: error -- expected valid id, got ~e" sym)])]
     [(list (? symbol? s) arg) (cond
                                 [(valid-id? s) (AppC s (parse arg))]
                                 [else (error "VVQS: error -- expected valid id")]
                                )]
     [other (error "VVQS: error -- expected expression, got ~e" other)])
  )


(check-equal? (parse '1) (NumC 1))
(check-equal? (parse '{+ 2 3}) (BinopC '+ (NumC 2) (NumC 3)))
(check-equal? (parse '{* 2 3}) (BinopC '* (NumC 2) (NumC 3)))
(check-equal? (parse '{* {+ 1 2} {+ 3 4}}) (BinopC '* (BinopC '+ (NumC 1) (NumC 2)) (BinopC '+ (NumC 3) (NumC 4))))
(check-equal? (parse '{+ {* 1 2} {* 3 4}}) (BinopC '+ (BinopC '* (NumC 1) (NumC 2)) (BinopC '* (NumC 3) (NumC 4))))

(check-equal? (parse '{hi 1 2}) (BinopC 'hi (NumC 1) (NumC 2)))  ; PARSERS ALLOWS ANY SYMBOL - FIX?

(check-exn #rx"VVQS" (lambda() (parse '{+ 4})))
(check-exn #rx"VVQS" (lambda() (parse '{+ / 4})))
(check-exn #rx"VVQS" (lambda() (parse '{+})))
(check-exn #rx"VVQS" (lambda() (parse '{})))
(check-exn #rx"VVQS" (lambda() (parse '{+ {+ 1 2}})))
(check-exn #rx"VVQS" (lambda() (parse '{* {+ 1 2}})))
(check-exn #rx"VVQS" (lambda() (parse '{* {+ 1 2} {+ 1}})))

#;(check-exn (regexp (regexp-quote "VVQS:"))
           (lambda () (parse '{- 2 3})))

(check-equal? (parse '{leq0? 1
                             then 1
                             else {- 1 1}})
              (Leq0 (NumC 1) (NumC 1) {BinopC '- (NumC 1) (NumC 1)}))
(check-equal? (parse '{leq0? {+ 1 -2}
                             then {- 10 {+ 1 2}}
                             else {- 1 1}})
              (Leq0 (BinopC '+ (NumC 1) (NumC -2))
                    (BinopC '- (NumC 10) (BinopC '+ (NumC 1) (NumC 2)))
                    {BinopC '- (NumC 1) (NumC 1)}))


;; PARSE FUNDEFS
(define (parse-fundef [expr : Sexp]) : FdC
  (match expr
    [(list 'def (list name arg) '= body) (cond
                                           [(and (valid-id? name) (valid-id? arg))
                                            (FdC (cast name Symbol) (cast arg Symbol) (parse body))]
                                           [else
                                            (error "VVQS: error -- expected valid function def id, got ~e" name)]) ]
    [other (error "VVQS: error -- expected valid function definition, got ~e" other)]))

(check-equal? (parse-fundef '{def {double x} = {* x 2}}) (FdC 'double 'x (BinopC '* (IdC 'x) (NumC 2))))
(check-equal? (parse-fundef '{def {add-one x} = {+ x 1}}) (FdC 'add-one 'x (BinopC '+ (IdC 'x) (NumC 1))))
(check-exn #rx"VVQS" (lambda() (parse-fundef '{def {double} = {* x 2}})))
(check-exn #rx"VVQS" (lambda() (parse-fundef '{def {/ x} = {* x 2}})))
(check-exn #rx"VVQS" (lambda() (parse-fundef '{def {double x} = })))
(check-exn #rx"VVQS" (lambda() (parse-fundef '{{double x} = {* x 2}})))
(check-exn #rx"VVQS" (lambda() (parse-fundef '{def = {* x 2}}))) 

;;PARSE-PROG
(define (parse-prog [s : Sexp]) : (Listof FdC)
  (match s
    ['() '()]
    [(cons (list 'def (list name arg) '= body) r) (cons (parse-fundef
                                                         (list 'def (list name arg) '= body)) (parse-prog r))] 
    [other (error "VVQS: code unbound by a function. got: ~e" other)]))

(check-equal? (parse-prog '{{def {double x} = {* x 2}}
                            {def {tri f} = {* f 3}}
                            {def {main init} = {double 7}}})
              (list (FdC 'double 'x (BinopC '* (IdC 'x) (NumC 2)))
                    (FdC 'tri 'f (BinopC '* (IdC 'f) (NumC 3)))
                    (FdC 'main 'init (AppC 'double (NumC 7))) ))
(check-equal? (parse-prog '{{def {double x} = {* x 2}}
                            {def {main init} = {+ 5 2}}})
              (list (FdC 'double 'x (BinopC '* (IdC 'x) (NumC 2)))
                    (FdC 'main 'init (BinopC '+ (NumC 5) (NumC 2))) ))


(check-exn #rx"VVQS" (lambda() (parse-prog '{"asd"})))


;; given a symbol and fds, returns an FdC with the given symbol, if it is in fds
(define (get-fundef [sym : Symbol] [fundefs : (Listof FdC)]) : FdC
  (match fundefs
    ['() (error "VVQS: No function found with the name: ~e" sym)]
    [(cons (FdC s arg b) r)
     (cond
       [(symbol=? s sym) (first fundefs)]
       [else (get-fundef sym r)])]))

(check-equal? (get-fundef 'main (parse-prog '{{def {double x} = {* x 2}}
                            {def {main init} = {double 7}}})) (FdC 'main 'init (AppC 'double (NumC 7))))


(check-exn #rx"VVQS" (lambda() (get-fundef 'NoFunc (parse-prog '{{def {double x} = {* x 2}}
                            {def {main init} = {double 7}}}))))



;; subst will substitute the argument value in the funcitons code 
;; https://cs.brown.edu/courses/cs173/2012/book/adding-functions.html#%28part._.Defining_.Data_.Representations%29
(define (subst [what : ExprC] [for : Symbol] [in : ExprC]) : ExprC
  (match in
    [(NumC n) in]
    [(IdC s) (cond
               [(symbol=? s for) what] ;; checks if symbol is the same of 'for'
               [else in])]
    [(AppC f a) (AppC f (subst what for a))] ;---;; not needed until recursive functions?
    [(BinopC s l r) (BinopC s (subst what for l) (subst what for r))]
    #;[other (error "VVQS: error -- expected valid symbol, got ~e" other)])) ;;cant reach bc must take in as an ExprC

(check-equal? (subst (NumC 3) 'x (BinopC '+ (NumC 5) (IdC 'd))) (BinopC '+ (NumC 5) (IdC 'd)))

;; INTERPETER
;; takes an ExprC and returns the result of the expression, if possible.
;; if not, an error is thrown
(define (interp [expr : ExprC] [fds : (Listof FdC)]): Real
  (match expr
    [(NumC n) n]
    [(BinopC op l r) ((get-operator op) (interp l fds) (interp r fds))]
    [(Leq0 test then else) (cond
                             [(<= (interp test fds) 0) (interp then fds)]
                             [else (interp else fds)]
                             )]
    [(AppC f a) (local ([define fd (get-fundef f fds)]) ;; from text book 
                  (interp (subst a
                                 (FdC-arg fd)
                                 (FdC-body fd))
                          fds))]
    [(IdC x) (error "VVQS : interp shouldnt get here... unbound var")]))




;;rest of interp tests
(check-equal? (interp (NumC 1) testFds) 1)
(check-equal? (interp (NumC 0) testFds) 0)
(check-equal? (interp (BinopC '+ (NumC 1) (NumC 2)) testFds) 3)
(check-equal? (interp (BinopC '* (NumC 1) (NumC 2)) testFds) 2)
(check-equal? (interp (BinopC '* (BinopC '+ (NumC 1) (NumC 10)) (NumC 2)) testFds) 22)

(check-equal? (interp (BinopC '* (BinopC '+ (NumC 1) (NumC 10)) (BinopC '+ (NumC 1) (NumC 2))) testFds) 33)
(check-equal? (interp (BinopC '+ (BinopC '+ (NumC 1) (NumC 10)) (BinopC '+ (NumC 1) (NumC 2))) testFds) 14)
(check-equal? (interp (BinopC '* (BinopC '+ (NumC 0) (NumC 0)) (BinopC '+ (NumC 0) (NumC 0))) testFds) 0)
(check-equal? (interp (BinopC '- (BinopC '+ (NumC 1) (NumC 2)) (BinopC '+ (NumC 1) (NumC 1))) testFds) 1)
(check-equal? (interp (BinopC '/ (BinopC '+ (NumC 2) (NumC 2)) (BinopC '+ (NumC 1) (NumC 1))) testFds) 2)
(check-equal? (interp (BinopC '/ (BinopC '* (NumC 2) (NumC 20)) (BinopC '- (NumC 7) (NumC 3))) testFds) 10)

(check-exn #rx"VVQS" (lambda() (interp (BinopC 'hi (NumC 1) (NumC 2)) testFds)))
(check-exn #rx"VVQS" (lambda() (interp (BinopC 'a (NumC 1) (BinopC '+ (NumC 1) (NumC 2))) testFds)))
(check-exn #rx"VVQS" (lambda() (interp (BinopC '+ (NumC 1) (BinopC 'a (NumC 1) (NumC 2))) testFds)))
(check-exn #rx"VVQS" (lambda() (interp (IdC 'v) testFds)))

(check-equal? (interp (Leq0 (NumC 1) (NumC 1) {BinopC '- (NumC 1) (NumC 1)}) testFds) 0)
(check-equal? (interp (Leq0 (NumC -1) (NumC 1) {BinopC '- (NumC 1) (NumC 1)}) testFds) 1)
(check-equal? (interp (Leq0 (BinopC '+ (NumC 1) (NumC 2)) (NumC 1) {BinopC '- (NumC 10) (NumC 1)}) testFds) 9)
(check-equal? (interp
               (Leq0 (BinopC '+ (NumC 1) (NumC -2))
                     (BinopC '* (NumC 10) (NumC 10))
                     {BinopC '- (NumC 10) (NumC 1)}) testFds)
              100)
(check-equal? (interp (Leq0 (BinopC '+ (NumC 1) (NumC 2))
                            (BinopC '* (NumC 10) (NumC 10))
                            {BinopC '- (NumC 10) (BinopC '* (NumC 1) (NumC 4))}) testFds) 6)
(check-equal? (interp (parse '(* 3 (+ 2 7))) testFds) 27)


;; tests on whole process - both parse and interp
(check-equal? (interp (parse '1) testFds) 1)
(check-equal? (interp (parse '{+ 2 3}) testFds) 5)
(check-equal? (interp (parse '{* 2 3}) testFds) 6)
(check-equal? (interp (parse '{* {+ 1 2} {+ 3 4}}) testFds) 21)
(check-equal? (interp (parse '{+ {* 1 2} {* 3 4}}) testFds) 14)
(check-equal? (interp (parse '{+ {* 1 {* 4 2}} {* 3 {+ 6 4}}}) testFds) 38)
(check-equal? (interp (parse '{- {* 3 {* 4 2}} {* 2 {+ 6 4}}}) testFds) 4)
(check-equal? (interp (parse '{- {/ {* 4 6} 3} {* 2 {+ 1 2}}}) testFds) 2)
(check-equal? (interp (parse '{/ {* 10 {* 5 2}} {* 2 {- 7 2}}}) testFds) 10)
(check-equal? (interp (parse '{leq0? (+ 1 4)
                                     then (* 4 5)
                                     else (- 4 (+ 1 2))}) testFds) 1)
(check-equal? (interp (parse '{leq0? (+ 1 -4)
                                     then (* 4 5)
                                     else (- 4 (+ 1 2))}) testFds) 20)



;; Interpret-fns takes a list of FdCs and returns the interpretation of the main function
(define (interp-fns [funs : (Listof FdC)]) : Real
  (interp (AppC 'main (NumC 0)) funs)) 


(: top-interp (Sexp -> Real))
(define (top-interp fun-sexps)
  (interp-fns (parse-prog fun-sexps)))

(check-equal?  (top-interp '{{def {double x} = {* 2 x}}
                            {def {main init} = {double 13}}}) 26)

(check-equal?  (interp-fns (parse-prog '{{def {double x} = {* 2 x}}
                            {def {main init} = {double 13}}})) 26)

(check-equal?  (interp-fns (parse-prog '{{def {makeNeg x} = {* -1 x}}
                                         {def {add5ThenMult2 x} = {* 2 {+ 5 x}}}
                                         {def {main init} = {+ {add2ThenNeg 12} {add5ThenMult2 2}}}
                                         {def {add2ThenNeg x} = {makeNeg {+ 2 x}}}})) 0) 

