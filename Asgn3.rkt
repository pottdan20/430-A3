#lang typed/racket
(require typed/rackunit)


;; 3 write parser and interp

;; Data definitions
(define-type ExprC (U NumC BinopC Leq0 IdC AppC))
(struct NumC ([n : Real]) #:transparent)

; fds
(define-type FunDefC (U FdC)) ;; ---------------------------------------------- fix 'U' once working. leave for now
(struct FdC ([name : Symbol] [arg : Symbol] [body : ExprC]) #:transparent)

; binop
(struct BinopC ([operator : Symbol] [l : ExprC] [r : ExprC]) #:transparent)

; conditional
(struct Leq0 ([test : ExprC] [then : ExprC] [else : ExprC]) #:transparent)

; function stuff
(struct IdC ([s : Symbol]) #:transparent) ;; an ID element
(struct AppC ([fun : Symbol] [expr : ExprC]) #:transparent) ;; application of a func


;;placeholder fds (function definitions) that will later be generated by parse-prog i think
(define fds ( list (FdC 'f 'x (BinopC '+ (NumC 2) (IdC 'x))) (FdC 'g 'y (BinopC '+ (NumC 5) (IdC 'y)))))


;; get-fundef
;;placeholder get-fundef
(define (get-fundef [s : Symbol] [fundefs : (Listof FunDefC)]) : FunDefC
  (FdC 'f 'x (BinopC '+ (NumC 2) (IdC 'x))))

;; 3.1 Binary Arithmetic Operators
(define (get-operator [operator : Symbol]) : (-> Real Real Real)
  (match operator
    ['+ +]
    ['* *]
    ['- -]
    ['/ /]
    [other (error "VVQS: error -- expected a valid operator (+, -, *, /), got ~e" other)]))



;; PARSER

;; takes an Sexp and returns the ExprC corresponding to the Sexp, if applicable.
;; if not, an error is thrown
(define (parse [expr : Sexp]) : ExprC
  (match expr
     [(? real? n) (NumC n)]
     [(list (? symbol? s) l r) (BinopC s (parse l) (parse r))]
     [(list 'leq0? test 'then then 'else else) (Leq0 (parse test) (parse then) (parse else))]
     [(? symbol? sym) (IdC (cast sym Symbol))]
     [other (error "VVQS: error -- expected expression, got ~e" other)])
  )


(check-equal? (parse '1) (NumC 1))
(check-equal? (parse '{+ 2 3}) (BinopC '+ (NumC 2) (NumC 3)))
(check-equal? (parse '{* 2 3}) (BinopC '* (NumC 2) (NumC 3)))
(check-equal? (parse '{* {+ 1 2} {+ 3 4}}) (BinopC '* (BinopC '+ (NumC 1) (NumC 2)) (BinopC '+ (NumC 3) (NumC 4))))
(check-equal? (parse '{+ {* 1 2} {* 3 4}}) (BinopC '+ (BinopC '* (NumC 1) (NumC 2)) (BinopC '* (NumC 3) (NumC 4))))

(check-equal? (parse '{hi 1 2}) (BinopC 'hi (NumC 1) (NumC 2)))  ; PARSERS ALLOWS ANY SYMBOL - FIX?

(check-exn #rx"VVQS" (lambda() (parse '{+ 4})))
(check-exn #rx"VVQS" (lambda() (parse '{+})))
(check-exn #rx"VVQS" (lambda() (parse '{})))
(check-exn #rx"VVQS" (lambda() (parse '{+ {+ 1 2}})))
(check-exn #rx"VVQS" (lambda() (parse '{* {+ 1 2}})))
(check-exn #rx"VVQS" (lambda() (parse '{* {+ 1 2} {+ 1}})))

#;(check-exn (regexp (regexp-quote "VVQS:"))
           (lambda () (parse '{- 2 3})))

(check-equal? (parse '{leq0? 1
                             then 1
                             else {- 1 1}})
              (Leq0 (NumC 1) (NumC 1) {BinopC '- (NumC 1) (NumC 1)}))
(check-equal? (parse '{leq0? {+ 1 -2}
                             then {- 10 {+ 1 2}}
                             else {- 1 1}})
              (Leq0 (BinopC '+ (NumC 1) (NumC -2)) (BinopC '- (NumC 10) (BinopC '+ (NumC 1) (NumC 2))) {BinopC '- (NumC 1) (NumC 1)}))



;; PARSE FUNDEFS
(define (parse-fundef [expr : Sexp]) : Any
  (match expr
    [(list 'def (list name arg) '= body) (FdC (cast name Symbol) (cast arg Symbol) (parse body)) ] ; (printf "~v" name)
    [other (error "VVQS: error -- expected valid function definition, got ~e" other)]))

(check-equal? (parse-fundef '{def {double x} = {* x 2}}) (FdC 'double 'x (BinopC '* (IdC 'x) (NumC 2))))
(check-equal? (parse-fundef '{def {add-one x} = {+ x 1}}) (FdC 'add-one 'x (BinopC '+ (IdC 'x) (NumC 1))))
(check-exn #rx"VVQS" (lambda() (parse-fundef '{def {double} = {* x 2}})))
(check-exn #rx"VVQS" (lambda() (parse-fundef '{def {double x} = })))
(check-exn #rx"VVQS" (lambda() (parse-fundef '{{double x} = {* x 2}})))
(check-exn #rx"VVQS" (lambda() (parse-fundef '{def = {* x 2}}))) 


;; subst will substitute the argument value in the funcitons code 
;; https://cs.brown.edu/courses/cs173/2012/book/adding-functions.html#%28part._.Defining_.Data_.Representations%29
(define (subst [what : ExprC] [for : Symbol] [in : ExprC]) : ExprC
  (match in
    [(NumC n) in]
    [(IdC s) (cond
               [(symbol=? s for) what] ;; not sure what symbol?= is but book had it
               [else in])]
    [(AppC f a) (AppC f (subst what for a))]
    [(BinopC s l r) (BinopC s (subst what for l) (subst what for r))]
    [other (error "VVQS: error -- expected valid symbol, got ~e" other)])) ;;maybe test??

;; INTERPETER

;; takes an ExprC and returns the result of the expression, if possible.
;; if not, an error is thrown
(define (interp [expr : ExprC] ): Real
  (match expr
    [(NumC n) n]
    [(BinopC op l r) ((get-operator op) (interp l) (interp r))]
    [(Leq0 test then else) (cond
                             [(<= (interp test) 0) (interp then)]
                             [else (interp else)]
                             )]
    [(AppC f a) (local ([define fd (get-fundef f fds)]) ;; from text book 
                  (interp (subst a
                                 (FdC-arg fd)
                                 (FdC-body fd))
                          ))]
    [(IdC x) (error "VVQS : interp shouldnt get here")])) 



(check-equal? (interp 
               (AppC 'f (NumC 7))) 9) ;; ---------- checks this f function that adds 2. its the only function I have hard coded into the fds list -------------------


#;(
(check-equal? (interp (NumC 1)) 1)
(check-equal? (interp (NumC 0)) 0)
(check-equal? (interp (BinopC '+ (NumC 1) (NumC 2))) 3)
(check-equal? (interp (BinopC '* (NumC 1) (NumC 2))) 2)
(check-equal? (interp (BinopC '* (BinopC '+ (NumC 1) (NumC 10)) (NumC 2))) 22)
(check-equal? (interp (BinopC '* (BinopC '+ (NumC 1) (NumC 10)) (BinopC '+ (NumC 1) (NumC 2)))) 33)
(check-equal? (interp (BinopC '+ (BinopC '+ (NumC 1) (NumC 10)) (BinopC '+ (NumC 1) (NumC 2)))) 14)
(check-equal? (interp (BinopC '* (BinopC '+ (NumC 0) (NumC 0)) (BinopC '+ (NumC 0) (NumC 0)))) 0)
(check-equal? (interp (BinopC '- (BinopC '+ (NumC 1) (NumC 2)) (BinopC '+ (NumC 1) (NumC 1)))) 1)
(check-equal? (interp (BinopC '/ (BinopC '+ (NumC 2) (NumC 2)) (BinopC '+ (NumC 1) (NumC 1)))) 2)
(check-equal? (interp (BinopC '/ (BinopC '* (NumC 2) (NumC 20)) (BinopC '- (NumC 7) (NumC 3)))) 10)

(check-exn #rx"VVQS" (lambda() (interp (BinopC 'hi (NumC 1) (NumC 2)))))
(check-exn #rx"VVQS" (lambda() (interp (BinopC 'a (NumC 1) (BinopC '+ (NumC 1) (NumC 2))))))
(check-exn #rx"VVQS" (lambda() (interp (BinopC '+ (NumC 1) (BinopC 'a (NumC 1) (NumC 2))))))

(check-equal? (interp (Leq0 (NumC 1) (NumC 1) {BinopC '- (NumC 1) (NumC 1)})) 0)
(check-equal? (interp (Leq0 (NumC -1) (NumC 1) {BinopC '- (NumC 1) (NumC 1)})) 1)
(check-equal? (interp (Leq0 (BinopC '+ (NumC 1) (NumC 2)) (NumC 1) {BinopC '- (NumC 10) (NumC 1)})) 9)
(check-equal? (interp (Leq0 (BinopC '+ (NumC 1) (NumC -2)) (BinopC '* (NumC 10) (NumC 10)) {BinopC '- (NumC 10) (NumC 1)})) 100)
(check-equal? (interp (Leq0 (BinopC '+ (NumC 1) (NumC 2)) (BinopC '* (NumC 10) (NumC 10)) {BinopC '- (NumC 10) (BinopC '* (NumC 1) (NumC 4))})) 6)
)
(check-equal? (interp (parse '(* 3 (+ 2 7)))) 27)






;; tests on whole process - both parse and interp
(check-equal? (interp (parse '1)) 1)
(check-equal? (interp (parse '{+ 2 3})) 5)
(check-equal? (interp (parse '{* 2 3})) 6)
(check-equal? (interp (parse '{* {+ 1 2} {+ 3 4}})) 21)
(check-equal? (interp (parse '{+ {* 1 2} {* 3 4}})) 14)
(check-equal? (interp (parse '{+ {* 1 {* 4 2}} {* 3 {+ 6 4}}})) 38)
(check-equal? (interp (parse '{- {* 3 {* 4 2}} {* 2 {+ 6 4}}})) 4)
(check-equal? (interp (parse '{- {/ {* 4 6} 3} {* 2 {+ 1 2}}})) 2)
(check-equal? (interp (parse '{/ {* 10 {* 5 2}} {* 2 {- 7 2}}})) 10)

(check-equal? (interp (parse '{leq0? (+ 1 4)
                                     then (* 4 5)
                                     else (- 4 (+ 1 2))})) 1)
(check-equal? (interp (parse '{leq0? (+ 1 -4)
                                     then (* 4 5)
                                     else (- 4 (+ 1 2))})) 20)

(check-exn #rx"VVQS" (lambda() (interp (parse '{+ 4}))))
(check-exn #rx"VVQS" (lambda() (interp (parse '{+}))))
(check-exn #rx"VVQS" (lambda() (interp (parse '{}))))


