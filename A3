#lang typed/racket
(require typed/rackunit)


;; 3 write parser and interp
;; ------------------------------------much of this is pulled from the textbook but was a little confusing.
(define-type ExprC (U numC plusC multC idC appC))
(struct numC ([n : Number]) #:transparent)
(define-type biop ( U plusC multC)) ;;------------------------ change later
(struct plusC ([l : ExprC] [r : ExprC]) #:transparent)
(struct multC ([l : ExprC] [r : ExprC]) #:transparent)
(struct idC ([s : Symbol]) #:transparent) ;; an ID element
(struct appC ([fun : Symbol] [expr : ExprC]) #:transparent) ;; application of a func





;; what I added to include functions and function definitions
(define-type FunDefC (U fdC)) ;; ---------------------------------------------- fix 'U' once working. leave for now
(struct fdC ([name : Symbol] [arg : Symbol] [body : ExprC]))

;;placeholder fds (function definitions) that will later be generated by parse-prog i think
(define fds ( list (fdC 'f 'x (plusC (numC 2) (idC 'x))) (fdC 'g 'y (plusC (numC 5) (idC 'y)))))
;;placeholder get-fundef
(define (get-fundef [s : Symbol] [fundefs : (Listof FunDefC)]) : FunDefC
  (fdC 'f 'x (plusC (numC 2) (idC 'x))))

;;parser
;;-----------------------------------------------needs parse for functions. this will come with new functions defined in the assignment description ---------------------

;;parse takes an Sexp and returns the correct ExprC --------- leave as is but maybe change as u add the other functions?
;;-----------------------------------------------------------I added the implementation for the interpreter and did the definitions for parse but havent done the parse for functions
(define (parse [expr : Sexp]) : ExprC
  (match expr
     [(? real? n) (numC n)]
     [(list '+ l r) (plusC (parse l) (parse r))]
     [(list '* l r) (multC (parse l) (parse r))]
     [other (error "VVQS: error -- expected expression, got ~e" other)]))

(check-equal? (parse '(* 2 3)) (multC (numC 2) (numC 3)))
(check-equal? (parse '(+ 2 3)) (plusC (numC 2) (numC 3)))
(check-exn (regexp (regexp-quote "VVQS:"))
           (lambda () (parse '{- 2 3})))


;; subst will substitute the argument value in the funcitons code 
;;https://cs.brown.edu/courses/cs173/2012/book/adding-functions.html#%28part._.Defining_.Data_.Representations%29
(define (subst [what : ExprC] [for : Symbol] [in : ExprC]) : ExprC
  (match in
    [(numC n) in]
    [(idC s) (cond
               [(symbol=? s for) what] ;; not sure what symbol?= is but book had it
               [else in])]
    [(appC f a) (appC f (subst what for a))]
    [(plusC l r) (plusC (subst what for l) (subst what for r))]
    [(multC l r) (multC (subst what for l) (subst what for r))]))

            

;; evaluate/interp 
;; takes an ExprC and returns the answer of that expression
;; ---------------------------------------------------------------should be pretty done for functions-----------------tested with easy func below
(define (interp [a : ExprC] [fds : (Listof FunDefC)]) : Number
  (match a
    [(numC n) n]
    [(plusC l r) (+ (interp l fds) (interp r fds))]
    [(multC l r) (* (interp l fds) (interp r fds))]
    [(appC f a) (local ([define fd (get-fundef f fds)]) ;; from text book 
                  (interp (subst a
                                 (fdC-arg fd)
                                 (fdC-body fd))
                          fds))]
    [(idC x) (error "VVQS : interp shouldnt get here")]
    ))

(check-equal? (interp
               (plusC (numC 3) (multC (numC 2) (numC 4))) fds) 11)
(check-equal? (interp
               (numC 0) fds)0)

(check-equal? (interp 
               (appC 'f (numC 7)) fds) 9) ;; ---------- checks this f function that adds 2. its the only function I have hard coded into the fds list -------------------


;;big check for all
(check-equal? (interp (parse '(* 3 (+ 2 7))) fds) 27) ;; doesnt include funtion parsing yet

